/*
 * (C) Copyright 2006-2010 Nuxeo SAS (http://nuxeo.com/) and contributors.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser General Public License
 * (LGPL) version 2.1 which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * Contributors:
 *     bstefanescu
 */
package org.nuxeo.ide.project;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.Status;
import org.eclipse.debug.core.ILaunchConfiguration;
import org.eclipse.pde.core.plugin.IPluginModelBase;
import org.eclipse.pde.launching.EquinoxLaunchConfiguration;
import org.nuxeo.ide.project.utils.FileUtils;
import org.nuxeo.ide.project.utils.StringUtils;

/**
 * @author <a href="mailto:bs@nuxeo.com">Bogdan Stefanescu</a>
 *
 */
public class NuxeoLaunchConfiguration extends EquinoxLaunchConfiguration {


    /**
     * intercept VM args and remove h2 lucene lock if any is present
     */
    @Override
    public String[] getVMArguments(ILaunchConfiguration configuration)
            throws CoreException {
        String[] args = super.getVMArguments(configuration);
        String lock = null;
        String nuxeoHome = null;
        for (int i=0; i<args.length; i++) {
            if (args[i].startsWith("-Dnuxeo.home=")) {
                nuxeoHome = args[i].substring("-Dnuxeo.home=".length());
            } else if (args[i].startsWith("-Dh2.baseDir=")) {
                lock = args[i].substring("-Dh2.baseDir=".length());
            }
        }
        if (lock != null) {
            lock = lock+File.separator+"nuxeo.lucene"+File.separator+"write.lock";
        } else if (nuxeoHome != null) {
            lock = nuxeoHome+File.separator+"data"+File.separator+"h2"
                +File.separator+"nuxeo.lucene"+File.separator+"write.lock";
        }
        if (lock != null) {
            new File(lock).delete();
        }
        return args;
    }

    /**
     * Fix config.ini to point to /bin directories and not to project roots.
     * Also dev.properties can be removed since pointing to bin will include classes in the bundle
     */
    @Override
    public String[] getProgramArguments(ILaunchConfiguration configuration) throws CoreException {
        String[] args = super.getProgramArguments(configuration);
        syncManifests(configuration);
        fixConfigFile(configuration);
        args = removeDevArg(args);
        return args;
    }

    public boolean fixConfigFile(ILaunchConfiguration configuration) throws CoreException {
        File config = getConfigFile(configuration);
        Properties props = new Properties();
        FileInputStream in = null;
        try {
            in = new FileInputStream(config);
            props.load(in);
        } catch (IOException e) {
            throw new CoreException(new Status(Status.ERROR, Activator.PLUGIN_ID, "Failed to load configuration", e));
        } finally {
            try { if (in != null) in.close(); } catch (Exception e) {
                throw new CoreException(new Status(Status.ERROR, Activator.PLUGIN_ID, "Failed to close stream", e));
            }
        }
        String bundles = props.getProperty("osgi.bundles");
        if (bundles == null) {
            return false;
        }
        bundles = bundles.trim();
        bundles = fixBundlePaths(bundles);
        props.setProperty("osgi.bundles", bundles);

        FileOutputStream out = null;
        try {
            out = new FileOutputStream(config);
            props.store(out, "# Generated by NuxeoLaunchConfiguration");
        } catch (IOException e) {
            throw new CoreException(new Status(Status.ERROR, Activator.PLUGIN_ID, "Failed to save configuration", e));
        } finally {
            try { if (out != null) out.close(); } catch (Exception e) {
                throw new CoreException(new Status(Status.ERROR, Activator.PLUGIN_ID, "Failed to close stream", e));
            }
        }
        return true;
    }

    public String[] removeDevArg(String[] args) {
        int k = -1;
        for (int i=0; i<args.length; i++) {
            if ("-dev".equals(args[i])) {
                k = i;
                break;
            }
        }
        if (k > -1) {
            String[] tmp = new String[args.length-2];
            System.arraycopy(args, 0, tmp, 0, k);
            if (k+2 < args.length) {
                System.arraycopy(args, k+2, tmp, k, args.length-k-2);
            }
            return tmp;
        }
        return args;
    }

    protected File getDevPropertiesFile(ILaunchConfiguration configuration) {
        return new File(getConfigDir(configuration).toString() + "/dev.properties");
    }

    protected File getConfigFile(ILaunchConfiguration configuration) {
        return new File(getConfigDir(configuration), "config.ini");
    }


    protected String fixBundlePaths(String bundles) {
        String[] ar = StringUtils.split(bundles, ',', true);
        for (int k=0; k<ar.length;k++) {
            String a = ar[k];
            int i = a.lastIndexOf('@');
            String suffix = null;
            if (i > -1) {
                suffix = a.substring(i);
                a = a.substring(0, i);
            }
            if (!a.endsWith(".jar") && !a.endsWith("/bin")) {
                a = a.concat("/bin");
            }
            if (suffix != null) {
                a = a.concat(suffix);
            }
            ar[k] = a;
        }
        return StringUtils.join(ar, ',');
    }


    protected void syncManifests(ILaunchConfiguration configuration) throws CoreException {
        for (Object entry : fAllBundles.values()) {
            IPluginModelBase model = (IPluginModelBase)entry;
            File file = new File(model.getInstallLocation());
            if (file.isDirectory()) {
                String path = "META-INF".concat(File.separator).concat("MANIFEST.MF");
                File dst = new File(file, "bin".concat(File.separator).concat(path));
                File src = new File(file, path);
                if (src.isFile()) {
                    try {
                        dst.getParentFile().mkdirs();
                        FileUtils.copy(src, dst);
                    } catch (IOException e) {
                        throw new CoreException(new Status(Status.ERROR, Activator.PLUGIN_ID, "Failed to synchronize manifest for " +file.getName(), e));
                    }
                }
            }

        }
    }

}
